
# HG changeset patch
# User Ryan Sleevi <ryan.sleevi@gmail.com>
# Date 1444930561 -7200
# Node ID c9c965b2b19cb7076dbadc19c9e68ec4a9cd4ea0
# Parent  f40f22264704fdb13026a4ee17749b2d2cc71605
Fix bug 1205157, r=wtc
Origin, upstream: http://hg.mozilla.org/projects/nspr/rev/c9c965b2b19c
Reviewed-by: Santiago R.R <santiagorr@riseup.net>

--- a/mozilla/nsprpub/lib/ds/plarena.c
+++ b/mozilla/nsprpub/lib/ds/plarena.c
@@ -126,6 +126,9 @@
         pool->mask = PR_BITMASK(PR_CeilingLog2(align));
 
     pool->first.next = NULL;
+    /* Set all three addresses in pool->first to the same dummy value.
+     * These addresses are only compared with each other, but never
+     * dereferenced. */
     pool->first.base = pool->first.avail = pool->first.limit =
         (PRUword)PL_ARENA_ALIGN(pool, &pool->first + 1);
     pool->current = &pool->first;
@@ -169,10 +172,14 @@
 {
     PLArena *a;   
     char *rp;     /* returned pointer */
+    PRUint32 nbOld;
 
     PR_ASSERT((nb & pool->mask) == 0);
     
+    nbOld = nb;
     nb = (PRUword)PL_ARENA_ALIGN(pool, nb); /* force alignment */
+    if (nb < nbOld)
+        return NULL;
 
     /* attempt to allocate from arenas at pool->current */
     {
@@ -232,6 +239,7 @@
             a->base = a->avail = (PRUword)PL_ARENA_ALIGN(pool, a + 1);
             rp = (char *)a->avail;
             a->avail += nb;
+            PR_ASSERT(a->avail <= a->limit);
             /* the newly allocated arena is linked after pool->current 
             *  and becomes pool->current */
             a->next = pool->current->next;
@@ -254,6 +262,8 @@
 {
     void *newp;
 
+    if (PR_UINT32_MAX - size < incr)
+        return NULL;
     PL_ARENA_ALLOCATE(newp, pool, size + incr);
     if (newp)
         memcpy(newp, p, size);
--- a/mozilla/nsprpub/lib/ds/plarena.h
+++ b/mozilla/nsprpub/lib/ds/plarena.h
@@ -91,6 +91,32 @@
 };
 
 /*
+ * WARNING: The PL_MAKE_MEM_ macros are for internal use by NSPR. Do NOT use
+ * them in your code.
+ *
+ * NOTE: Valgrind support to be added.
+ *
+ * The PL_MAKE_MEM_ macros are modeled after the MOZ_MAKE_MEM_ macros in
+ * Mozilla's mfbt/MemoryChecking.h. Only AddressSanitizer is supported now.
+ *
+ * Provides a common interface to the ASan (AddressSanitizer) and Valgrind
+ * functions used to mark memory in certain ways. In detail, the following
+ * three macros are provided:
+ *
+ *   PL_MAKE_MEM_NOACCESS  - Mark memory as unsafe to access (e.g. freed)
+ *   PL_MAKE_MEM_UNDEFINED - Mark memory as accessible, with content undefined
+ *   PL_MAKE_MEM_DEFINED - Mark memory as accessible, with content defined
+ *
+ * With Valgrind in use, these directly map to the three respective Valgrind
+ * macros. With ASan in use, the NOACCESS macro maps to poisoning the memory,
+ * while the UNDEFINED/DEFINED macros unpoison memory.
+ *
+ * With no memory checker available, all macros expand to the empty statement.
+ */
+
+#define PL_MAKE_MEM_UNDEFINED(addr, size)
+
+/*
  * If the including .c file uses only one power-of-2 alignment, it may define
  * PL_ARENA_CONST_ALIGN_MASK to the alignment mask and save a few instructions
  * per ALLOCATE and GROW.
@@ -110,29 +136,36 @@
         PLArena *_a = (pool)->current; \
         PRUint32 _nb = PL_ARENA_ALIGN(pool, nb); \
         PRUword _p = _a->avail; \
-        PRUword _q = _p + _nb; \
-        if (_q > _a->limit) \
+        if (_nb < nb) { \
+            _p = 0; \
+        } else if (_nb > (_a->limit - _a->avail)) { \
             _p = (PRUword)PL_ArenaAllocate(pool, _nb); \
-        else \
-            _a->avail = _q; \
+        } else { \
+            _a->avail += _nb; \
+        } \
         p = (void *)_p; \
-        PL_ArenaCountAllocation(pool, nb); \
+        if (p) { \
+            PL_MAKE_MEM_UNDEFINED(p, nb); \
+            PL_ArenaCountAllocation(pool, nb); \
+        } \
     PR_END_MACRO
 
 #define PL_ARENA_GROW(p, pool, size, incr) \
     PR_BEGIN_MACRO \
         PLArena *_a = (pool)->current; \
         PRUint32 _incr = PL_ARENA_ALIGN(pool, incr); \
-        PRUword _p = _a->avail; \
-        PRUword _q = _p + _incr; \
-        if (_p == (PRUword)(p) + PL_ARENA_ALIGN(pool, size) && \
-            _q <= _a->limit) { \
-            _a->avail = _q; \
+        if (_incr < incr) { \
+            p = NULL; \
+        } else if (_a->avail == (PRUword)(p) + PL_ARENA_ALIGN(pool, size) && \
+            _incr <= (_a->limit - _a->avail)) { \
+            _a->avail += _incr; \
             PL_ArenaCountInplaceGrowth(pool, size, incr); \
         } else { \
             p = PL_ArenaGrow(pool, p, size, incr); \
         } \
-        PL_ArenaCountGrowth(pool, size, incr); \
+        if (p) {\
+            PL_ArenaCountGrowth(pool, size, incr); \
+        } \
     PR_END_MACRO
 
 #define PL_ARENA_MARK(pool) ((void *) (pool)->current->avail)
